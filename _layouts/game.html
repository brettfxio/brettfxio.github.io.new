
<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8" />
		<title>three-vrm example</title>
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
	</head>

	<body>
		<div id="zone_joystick"></div>


		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.154.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
					"@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js",
					"cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js",
					"nipplejs": "https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.js"

				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
			import * as CANNON from "cannon-es";
			import { loadMixamoAnimation } from 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/humanoidAnimation/loadMixamoAnimation.js';
			import { Sky } from 'three/addons/objects/Sky.js';
			import * as nipplejs from 'nipplejs';

			// renderer
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 0.6;
			document.body.appendChild( renderer.domElement );

			// camera
			const CAMERA_FOV = 30.0;
			const CAMERA_Z = -10.0;
			const camera = new THREE.PerspectiveCamera( CAMERA_FOV, window.innerWidth / window.innerHeight, 0.1, 20.0 );
			camera.position.set( 0.0, 0.0, CAMERA_Z );			

			// camera controls
			const controls = new OrbitControls( camera, renderer.domElement );
			controls.screenSpacePanning = true;
			controls.target.set( 0.0, 1.0, 0.0 );
			controls.enabled = true;
			controls.update();

			// scene
			const scene = new THREE.Scene();

			// light
			const light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1.0, 1.0, 1.0 ).normalize();
			scene.add( light );

			// gltf and vrm
			let current = undefined;
			let currentAnimationUrl = undefined;
			let currentMixer = undefined;

			let sky, sun;

			// cannon.js variables
			let world;
			let body;

			// animate
			const clock = new THREE.Clock();
			clock.start();

			class Character {
				constructor(settings) {
					this.settings = settings;
					this.mixer = undefined;
					this.model = this.settings.model;
					this.vrm = undefined;
					this.stateMachine = undefined;
					this.loader = undefined;			
				}

				animate(deltaTime) {
					// if animation is loaded
					if ( this.mixer ) {
							// update the animation
							this.mixer.update( deltaTime );
						}	
						
						// update vrm components
						if ( this.vrm ) {
							this.vrm.update( clock.getDelta() );
						}						
					}

				init() {
					this.loader = new GLTFLoader();
					this.loader.crossOrigin = 'anonymous';
					this.loader.register( ( parser ) => {
						return new VRMLoaderPlugin( parser );
					} );	

					this.stateMachine = 

					this.loader.load(

						// URL of the VRM you want to load
						this.model,

						// called when the resource is loaded
						( gltf ) => {

							this.vrm = gltf.userData.vrm;

							// calling these functions greatly improves the performance
							VRMUtils.removeUnnecessaryVertices( gltf.scene );
							VRMUtils.removeUnnecessaryJoints( gltf.scene );

							// Disable frustum culling
							this.vrm.scene.traverse( ( obj ) => {
								obj.frustumCulled = false;
							} );

							//current = this.vrm;
							console.log( this.vrm );
							this.vrm.scene.position.set( this.settings.origin[0], this.settings.origin[1], this.settings.origin[2]);
							scene.add( this.vrm.scene );

							// create AnimationMixer for VRM
							this.mixer = new THREE.AnimationMixer( this.vrm.scene );

							// Load animation
							loadMixamoAnimation( this.settings.state.states.start.animation, this.vrm ).then( ( clip ) => {

								// Apply the loaded animation to mixer and play
								this.mixer.clipAction( clip ).play();
								this.mixer.timeScale = 1;

							} );


						},

						// called while loading is progressing
						( progress ) => console.log( 'Loading model...', 100.0 * ( progress.loaded / progress.total ), '%' ),

						// called when loading has errors
						( error ) => console.error( error )

					);
					
				}
			}

			var settings = {
				'model': function () { return 'model' },
				'origin': function () { return 'origin' },
				'state' : {
					// The initial state
					initialState: "start",
					// The list of states
					states: {
						start: {
							animation: function () { return 'startAnimation' },
							// The list of transitions
							transitions: [
								{
								// The event that triggers the transition
								event: "click",
								// The new state
								newState: "end"
								}
							]
						},
						end: {}
					}
				}
			}

			// templatize our settings
			var templateMaker = function (object) {
				return function (context) {
					var replacer = function (key, val) {
						if (typeof val === 'function') {
							return context[val()]
						}
						return val;
					}
					return JSON.parse(JSON.stringify(settings, replacer))
				}
			}

			var template = templateMaker(settings);

			var data = {
				model: './assets/Kohen.vrm',
				origin: [1, 0, 0],
				startAnimation: './assets/idle2.fbx'
			}

			var k = new Character(template(data));
			k.init();
			
			var data = {
				model: './assets/Eislee.vrm',
				origin: [-1, 0, 0],
				startAnimation: './assets/idle.fbx'
			}

			var e = new Character(template(data));
			e.init();

			var characters = [];
			characters.push(k);
			characters.push(e);

			world = new CANNON.World()
			world.gravity.set(0, -40, 0)

			// Tweak contact properties.
			// Contact stiffness - use to make softer/harder contacts
			world.defaultContactMaterial.contactEquationStiffness = 1e8

			// Stabilization time in number of timesteps
			world.defaultContactMaterial.contactEquationRelaxation = 10
			const groundShape = new CANNON.Plane()

			body = new CANNON.Body({mass: 0})
			body.addShape(groundShape)
			body.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
			world.addBody(body)

			// Add Sky
			sky = new Sky();
			sky.scale.setScalar( 450000 );
			scene.add( sky );

			sun = new THREE.Vector3();

			const effectController = {
				turbidity: 10,
				rayleigh: 3,
				mieCoefficient: 0.005,
				mieDirectionalG: 0.7,
				elevation: 2,
				azimuth: 180,
				exposure: renderer.toneMappingExposure
			};

			const uniforms = sky.material.uniforms;
			uniforms[ 'turbidity' ].value = effectController.turbidity;
			uniforms[ 'rayleigh' ].value = effectController.rayleigh;
			uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
			uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

			const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
			const theta = THREE.MathUtils.degToRad( effectController.azimuth );

			sun.setFromSphericalCoords( 1, phi, theta );

			uniforms[ 'sunPosition' ].value.copy( sun );

			renderer.toneMappingExposure = effectController.exposure;
			renderer.render( scene, camera );

			// mixamo animation
			function loadFBX( animationUrl ) {

				currentAnimationUrl = animationUrl;

				// create AnimationMixer for VRM
				currentMixer = new THREE.AnimationMixer( current.scene );

				// Load animation
				loadMixamoAnimation( animationUrl, current ).then( ( clip ) => {

					// Apply the loaded animation to mixer and play
					currentMixer.clipAction( clip ).play();
					currentMixer.timeScale = 1;

				} );
			}

			// helpers
			const gridHelper = new THREE.GridHelper( 10, 10 );
			scene.add( gridHelper );

			const axesHelper = new THREE.AxesHelper( 5 );
			scene.add( axesHelper );

			function animate() {

				world.fixedStep()
				
				const deltaTime = clock.getDelta();

				requestAnimationFrame( animate );

				// loop through all of our characters that need animation
				for(var i = 0; i < characters.length; i++) {
					characters[i].animate(deltaTime)
				}

				// render
				renderer.render( scene, camera );
			}

			animate();

			// dnd handler
			window.addEventListener( 'dragover', function ( event ) {
				event.preventDefault();
			} );

			window.addEventListener( 'drop', function ( event ) {
				event.preventDefault();

				// read given file then convert it to blob url
				const files = event.dataTransfer.files;
				if ( ! files ) return;

				const file = files[ 0 ];
				if ( ! file ) return;

				const fileType = file.name.split( '.' ).pop();
				const blob = new Blob( [ file ], { type: 'application/octet-stream' } );
				const url = URL.createObjectURL( blob );

				if ( fileType === 'fbx' ) {
					loadFBX( url );
				} else {
					loadVRM( url );
				}

			} );

			
			document.addEventListener('keydown', function(event) {

				const oldObjectPosition = new THREE.Vector3();
				current.scene.getWorldPosition(oldObjectPosition);

				// NOTE Move object
				if(event.keyCode == 87) { // w
					current.scene.position.z +=0.1;

					// create AnimationMixer for VRM
					currentMixer = new THREE.AnimationMixer( current.scene );

					// Load animation
					loadMixamoAnimation( '/assets/run_forward.fbx', current ).then( ( clip ) => {

						// Apply the loaded animation to mixer and play
						currentMixer.clipAction( clip ).play();
						currentMixer.timeScale = 1;

					} );

				}

				if(event.keyCode == 65) { // a
					current.scene.position.x +=0.1;
				}

				if(event.keyCode == 83) { // s
					current.scene.position.z -=0.1;
				}

				if(event.keyCode == 68) { // d
					current.scene.position.x -=0.1;
				}				


				const newObjectPosition = new THREE.Vector3();
				current.scene.getWorldPosition(newObjectPosition);

				const delta = newObjectPosition.clone().sub(oldObjectPosition);

				camera.position.add(delta);
			} );


			var options = {
				zone: document.getElementById('zone_joystick'),
			};
			// TODO: Need to get this working
			//var manager = nipplejs.create(options);
		</script>
	</body>
</html>
