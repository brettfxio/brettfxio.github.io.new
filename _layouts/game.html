
<!DOCTYPE html>

<html>
	<head>
		<meta charset="utf-8" />
		<title>three-vrm example</title>
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
		/>
		<style>
			body {
				margin: 0;
			}
			canvas {
				display: block;
			}
		</style>
	</head>

	<body>
		<div id="zone_joystick"></div>


		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.154.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
					"@pixiv/three-vrm": "https://unpkg.com/@pixiv/three-vrm@2.0.6/lib/three-vrm.module.js",
					"cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js",
					"nipplejs": "https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.js"

				}
			}
		</script>

		<script type="module">
			import * as THREE from 'three';
			import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { VRMLoaderPlugin, VRMUtils } from '@pixiv/three-vrm';
			import * as CANNON from "cannon-es";
			import { loadMixamoAnimation } from 'https://pixiv.github.io/three-vrm/packages/three-vrm/examples/humanoidAnimation/loadMixamoAnimation.js';
			import { Sky } from 'three/addons/objects/Sky.js';
			import * as nipplejs from 'nipplejs';

			// renderer
			const renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.toneMapping = THREE.ACESFilmicToneMapping;
			renderer.toneMappingExposure = 0.6;
			document.body.appendChild( renderer.domElement );

			// camera
			const CAMERA_FOV = 30.0;
			const CAMERA_Z = -10.0;
			const camera = new THREE.PerspectiveCamera( CAMERA_FOV, window.innerWidth / window.innerHeight, 0.1, 20.0 );
			camera.position.set( 0.0, 0.0, CAMERA_Z );			

			// camera controls
			const controls = new OrbitControls( camera, renderer.domElement );
			controls.screenSpacePanning = true;
			controls.target.set( 0.0, 1.0, 0.0 );
			controls.enabled = true;
			controls.update();

			// scene
			const scene = new THREE.Scene();

			// light
			const light = new THREE.DirectionalLight( 0xffffff );
			light.position.set( 1.0, 1.0, 1.0 ).normalize();
			scene.add( light );

			// gltf and vrm
			let current = undefined;
			let currentAnimationUrl = undefined;
			let currentMixer = undefined;

			let sky, sun;

			// cannon.js variables
			let world;
			let body;

			// animate
			const clock = new THREE.Clock();
			clock.start();




			class Character
			{
				constructor(settings)
				{
					this.settings = settings;
					this.mixer = undefined;
					this.model = this.settings.model;
					this.vrm = undefined;
					this.stateMachine = undefined;
					this.loader = undefined;		

					this.machine = this.createMachine(this, {
						initialState: 'off',
						off: {
							actions: {
								onEnter(obj) {
									console.log('off: onEnter')
								},
								onExit(obj) {
									console.log('off: onExit')
								},
							},
							transitions: {
								switch: {
									target: 'init',
									action(obj) {
										console.log('transition action for "switch" in "off" state')
									},
								},
							},
						},
						init: {
							actions: {
								onEnter(obj) {
									console.log('init: onEnter')

									obj.init();
								},
								onExit(obj) {
									console.log('init: onExit')
								},
							},
							transitions: {
								switch: {
									target: 'idle',
									action(obj) {
										console.log('transition action for "switch" in "init" state')
									},
								},
							},
						},
						idle: {
							actions: {
								onEnter(obj) {
									console.log('idle: onEnter')
									obj.idle();
								},
								onExit(obj) {
									console.log('idle: onExit')
								},
							},
							transitions: {
								attack: {
									target: 'attack',
									action(obj) {
										console.log('transition action for "attack" in "idle" state')
									},
								},
							},
						},
						attack: {
							actions: {
								onEnter(obj) {
									console.log('attack: onEnter')
								},
								onExit(obj) {
									console.log('attack: onExit')
								},
							},
							transitions: {
								idle: {
									target: 'idle',
									action() {
										console.log('transition action for "idle" in "attack" state')
									},
								},
							},
						},
					})
				}

				createMachine(obj, stateMachineDefinition)
				{
					const machine = {
						value: stateMachineDefinition.initialState,
						transition(currentState, event) {
							const currentStateDefinition = stateMachineDefinition[currentState]
							const destinationTransition = currentStateDefinition.transitions[event]
							if (!destinationTransition) {
								return
							}
							const destinationState = destinationTransition.target
							const destinationStateDefinition =
								stateMachineDefinition[destinationState]

							destinationTransition.action(obj)
							currentStateDefinition.actions.onExit(obj)
							destinationStateDefinition.actions.onEnter(obj)

							machine.value = destinationState

							return machine.value
						},
					}
					return machine
				}

				animate(deltaTime)
				{
					// if animation is loaded
					if ( this.mixer ) {
						// update the animation
						this.mixer.update( deltaTime );
					}	
						
					// update vrm components
					if ( this.vrm ) {
						this.vrm.update( clock.getDelta() );
					}						
				}
				
				idle() {
					// Load animation
					loadMixamoAnimation( this.settings.idleAnimation, this.vrm ).then( ( clip ) => {
						// Apply the loaded animation to mixer and play
						this.mixer.clipAction( clip ).play();
					} );
				}

				init()
				{
					this.loader = new GLTFLoader();
					this.loader.crossOrigin = 'anonymous';
					this.loader.register( ( parser ) => {
						return new VRMLoaderPlugin( parser );
					} );	

					this.loader.load(

						// URL of the VRM you want to load
						this.model,

						// called when the resource is loaded
						( gltf ) => {

							this.vrm = gltf.userData.vrm;

							// calling these functions greatly improves the performance
							VRMUtils.removeUnnecessaryVertices( gltf.scene );
							VRMUtils.removeUnnecessaryJoints( gltf.scene );

							// Disable frustum culling
							this.vrm.scene.traverse( ( obj ) => {
								obj.frustumCulled = false;
							} );

							//current = this.vrm;
							console.log( this.vrm );
							this.vrm.scene.position.set( this.settings.origin[0], this.settings.origin[1], this.settings.origin[2]);
							scene.add( this.vrm.scene );

							// create AnimationMixer for VRM
							this.mixer = new THREE.AnimationMixer( this.vrm.scene );
							this.mixer.timeScale = 2;

							// switch to idle state
							this.machine.transition(this.machine.value, 'switch');
						},

						// called while loading is progressing
						( progress ) => console.log( 'Loading model...', 100.0 * ( progress.loaded / progress.total ), '%' ),

						// called when loading has errors
						( error ) => console.error( error )

					);
					
				}
			}

			var settings = {
				'model': function () { return 'model' },
				'origin': function () { return 'origin' },
				'idleAnimation': function () { return 'idleAnimation' }
			}

			// templatize our settings
			var templateMaker = function (object) {
				return function (context) {
					var replacer = function (key, val) {
						if (typeof val === 'function') {
							return context[val()]
						}
						return val;
					}
					return JSON.parse(JSON.stringify(settings, replacer))
				}
			}

			var template = templateMaker(settings);

			var data = {
				model: './assets/Kohen.vrm',
				origin: [1, 0, 0],
				idleAnimation: './assets/idle_breathing.fbx'
			}

			var k = new Character(template(data));
			let statek = k.machine.value
			console.log(`current state: ${statek}`)
			statek = k.machine.transition(statek, 'switch')
			console.log(`current state: ${statek}`)

			var data = {
				model: './assets/Eislee.vrm',
				origin: [-1, 0, 0],
				idleAnimation: './assets/idle_wide.fbx'
			}

			var e = new Character(template(data));
			let statee = e.machine.value
			console.log(`current state: ${statee}`)
			statee = e.machine.transition(statee, 'switch')
			console.log(`current state: ${statee}`)

			var characters = [];
			characters.push(e);
			characters.push(k);
			
			current = characters[0];

			world = new CANNON.World()
			world.gravity.set(0, -40, 0)

			// Tweak contact properties.
			// Contact stiffness - use to make softer/harder contacts
			world.defaultContactMaterial.contactEquationStiffness = 1e8

			// Stabilization time in number of timesteps
			world.defaultContactMaterial.contactEquationRelaxation = 10
			const groundShape = new CANNON.Plane()

			body = new CANNON.Body({mass: 0})
			body.addShape(groundShape)
			body.quaternion.setFromEuler(-Math.PI / 2, 0, 0)
			world.addBody(body)

			// Add Sky
			sky = new Sky();
			sky.scale.setScalar( 450000 );
			scene.add( sky );

			sun = new THREE.Vector3();

			const effectController = {
				turbidity: 10,
				rayleigh: 3,
				mieCoefficient: 0.005,
				mieDirectionalG: 0.7,
				elevation: 2,
				azimuth: 180,
				exposure: renderer.toneMappingExposure
			};

			const uniforms = sky.material.uniforms;
			uniforms[ 'turbidity' ].value = effectController.turbidity;
			uniforms[ 'rayleigh' ].value = effectController.rayleigh;
			uniforms[ 'mieCoefficient' ].value = effectController.mieCoefficient;
			uniforms[ 'mieDirectionalG' ].value = effectController.mieDirectionalG;

			const phi = THREE.MathUtils.degToRad( 90 - effectController.elevation );
			const theta = THREE.MathUtils.degToRad( effectController.azimuth );

			sun.setFromSphericalCoords( 1, phi, theta );

			uniforms[ 'sunPosition' ].value.copy( sun );

			renderer.toneMappingExposure = effectController.exposure;
			renderer.render( scene, camera );

			// mixamo animation
			function loadFBX( animationUrl ) {

				currentAnimationUrl = animationUrl;

				// create AnimationMixer for VRM
				currentMixer = new THREE.AnimationMixer( current.scene );

				// Load animation
				loadMixamoAnimation( animationUrl, current ).then( ( clip ) => {

					// Apply the loaded animation to mixer and play
					currentMixer.clipAction( clip ).play();

				} );
			}

			// helpers
			const gridHelper = new THREE.GridHelper( 10, 10 );
			scene.add( gridHelper );

			const axesHelper = new THREE.AxesHelper( 5 );
			scene.add( axesHelper );

			function animate() {

				world.fixedStep()
				
				const deltaTime = clock.getDelta();

				requestAnimationFrame( animate );

				// loop through all of our characters that need animation
				for(var i = 0; i < characters.length; i++) {
					characters[i].animate(deltaTime)
				}

				// render
				renderer.render( scene, camera );
			}

			animate();

			// dnd handler
			window.addEventListener( 'dragover', function ( event ) {
				event.preventDefault();
			} );

			window.addEventListener( 'drop', function ( event ) {
				event.preventDefault();

				// read given file then convert it to blob url
				const files = event.dataTransfer.files;
				if ( ! files ) return;

				const file = files[ 0 ];
				if ( ! file ) return;

				const fileType = file.name.split( '.' ).pop();
				const blob = new Blob( [ file ], { type: 'application/octet-stream' } );
				const url = URL.createObjectURL( blob );

				if ( fileType === 'fbx' ) {
					loadFBX( url );
				} else {
					loadVRM( url );
				}

			} );


			document.addEventListener('keydown', function(event) {

				const oldObjectPosition = new THREE.Vector3();
				current.vrm.scene.getWorldPosition(oldObjectPosition);

				// NOTE Move object
				if(event.keyCode == 87) { // w
					current.vrm.scene.position.z +=0.1;

					// create AnimationMixer for VRM
					current.mixer = new THREE.AnimationMixer( current.vrm.scene );

					// Load animation
					loadMixamoAnimation( '/assets/run_forward.fbx', current.vrm ).then( ( clip ) => {

						// Apply the loaded animation to mixer and play
						current.mixer.clipAction( clip ).play();

					} );
				}

				if(event.keyCode == 69) { // e
					// create AnimationMixer for VRM
					current.mixer = new THREE.AnimationMixer( current.vrm.scene );

					// Load animation
					loadMixamoAnimation( '/assets/cast2.fbx', current.vrm ).then( ( clip ) => {

						// Apply the loaded animation to mixer and play
						current.mixer.clipAction( clip ).play();

					} );
				}

				if(event.keyCode == 32) { // space bar
					// create AnimationMixer for VRM
					current.mixer = new THREE.AnimationMixer( current.vrm.scene );

					// Load animation
					loadMixamoAnimation( '/assets/cast.fbx', current.vrm ).then( ( clip ) => {

						// Apply the loaded animation to mixer and play
						current.mixer.clipAction( clip ).play();
						current.mixer.timeScale = 1;

					} );
				}

				if(event.keyCode == 49) { // 1
					current = e;
				}

				if(event.keyCode == 50) { // 2
					current = k;
				}

				if(event.keyCode == 65) { // a
					current.vrm.scene.position.x +=0.1;
				}

				if(event.keyCode == 83) { // s
					current.vrm.scene.position.z -=0.1;
				}

				if(event.keyCode == 68) { // d
					current.vrm.scene.position.x -=0.1;
				}				


				const newObjectPosition = new THREE.Vector3();
				current.vrm.scene.getWorldPosition(newObjectPosition);

				const delta = newObjectPosition.clone().sub(oldObjectPosition);

				camera.position.add(delta);
			} );


			var options = {
				zone: document.getElementById('zone_joystick'),
			};
			// TODO: Need to get this working
			//var manager = nipplejs.create(options);
		</script>
	</body>
</html>
